"""
Comprehensive JWT Authentication Diagnostic Command

This command provides detailed diagnostics for JWT authentication issues in production,
with specific focus on identifying configuration problems that prevent login/authentication.
"""

import os
import sys
import json
import traceback
from datetime import datetime, timedelta
from pathlib import Path

from django.core.management.base import BaseCommand, CommandError
from django.conf import settings
from django.contrib.auth import get_user_model
from django.test import RequestFactory
from django.utils import timezone
from django.core.cache import cache

from rest_framework.test import APIRequestFactory
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.exceptions import InvalidToken, TokenError

# JWT cookie authentication removed - using simplified auth only
# from apps.authentication.jwt_cookie_authentication import JWTCookieAuthentication
# from apps.authentication.cookie_middleware import set_jwt_cookies, clear_jwt_cookies
from apps.authentication.security_logging import log_security_event, SecurityEvent

User = get_user_model()


class Command(BaseCommand):
    help = 'Comprehensive JWT authentication diagnostics for production issues'

    def add_arguments(self, parser):
        parser.add_argument(
            '--verbose',
            action='store_true',
            help='Enable verbose output with detailed explanations',
        )
        parser.add_argument(
            '--test-user',
            type=str,
            help='Email of test user for authentication testing (creates if not exists)',
        )
        parser.add_argument(
            '--check-logs',
            action='store_true',
            help='Analyze recent authentication failures from security logs',
        )
        parser.add_argument(
            '--fix-permissions',
            action='store_true',
            help='Fix JWT key file permissions if incorrect',
        )

    def handle(self, *args, **options):
        self.verbosity = options.get('verbosity', 1)
        self.verbose = options.get('verbose', False)
        
        self.stdout.write(
            self.style.SUCCESS('üîç JWT Authentication Diagnostic Tool\n')
        )
        
        # Run comprehensive diagnostics
        try:
            self.run_diagnostics(options)
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'‚ùå Diagnostic failed with error: {e}')
            )
            if self.verbose:
                self.stdout.write(traceback.format_exc())
            raise CommandError('Diagnostic execution failed')

    def run_diagnostics(self, options):
        """Run all diagnostic checks"""
        diagnostics = [
            ('Environment Configuration', self.check_environment),
            ('JWT Key Validation', self.check_jwt_keys),
            ('Algorithm Compatibility', self.check_algorithm_compatibility),
            ('Token Generation/Verification', self.check_token_operations),
            ('Cookie Configuration', self.check_cookie_configuration),
            ('CORS & Security Settings', self.check_cors_security),
            ('Authentication Classes', self.check_authentication_classes),
            ('Production Environment', self.check_production_environment),
            ('Database Connectivity', self.check_database_connectivity),
        ]

        results = {}
        for name, check_func in diagnostics:
            self.stdout.write(f'\nüìã {name}')
            self.stdout.write('‚îÄ' * 50)
            
            try:
                result = check_func(options)
                results[name] = result
                if result.get('status') == 'success':
                    self.stdout.write(self.style.SUCCESS('‚úÖ PASSED'))
                elif result.get('status') == 'warning':
                    self.stdout.write(self.style.WARNING('‚ö†Ô∏è  WARNING'))
                else:
                    self.stdout.write(self.style.ERROR('‚ùå FAILED'))
            except Exception as e:
                self.stdout.write(self.style.ERROR(f'‚ùå ERROR: {e}'))
                results[name] = {'status': 'error', 'error': str(e)}
                if self.verbose:
                    self.stdout.write(traceback.format_exc())

        # Optional user authentication test
        if options.get('test_user'):
            self.stdout.write(f'\nüß™ User Authentication Test')
            self.stdout.write('‚îÄ' * 50)
            try:
                result = self.test_user_authentication(options['test_user'])
                results['User Authentication Test'] = result
                if result.get('status') == 'success':
                    self.stdout.write(self.style.SUCCESS('‚úÖ PASSED'))
                else:
                    self.stdout.write(self.style.ERROR('‚ùå FAILED'))
            except Exception as e:
                self.stdout.write(self.style.ERROR(f'‚ùå ERROR: {e}'))

        # Optional log analysis
        if options.get('check_logs'):
            self.stdout.write(f'\nüìä Authentication Log Analysis')
            self.stdout.write('‚îÄ' * 50)
            try:
                result = self.analyze_auth_logs()
                results['Log Analysis'] = result
            except Exception as e:
                self.stdout.write(self.style.ERROR(f'‚ùå ERROR: {e}'))

        # Summary and recommendations
        self.provide_summary_and_recommendations(results)

    def check_environment(self, options):
        """Check environment configuration"""
        issues = []
        info = []
        
        # Check Django settings
        info.append(f"Environment: {os.environ.get('DJANGO_SETTINGS_MODULE', 'Not set')}")
        info.append(f"Debug mode: {settings.DEBUG}")
        info.append(f"Secret key set: {'Yes' if settings.SECRET_KEY else 'No'}")
        
        # Check environment variables
        env_vars = [
            'DJANGO_SECRET_KEY',
            'JWT_SECRET_KEY', 
            'FRONTEND_URL',
            'BACKEND_URL',
            'CORS_ALLOWED_ORIGINS',
        ]
        
        for var in env_vars:
            value = os.environ.get(var)
            if value:
                # Show partial value for security
                display_value = f"{value[:10]}..." if len(value) > 10 else value
                info.append(f"{var}: {display_value}")
            else:
                info.append(f"{var}: Not set")
                if var == 'DJANGO_SECRET_KEY':
                    issues.append("DJANGO_SECRET_KEY not set in environment")

        # Check URL configuration
        frontend_url = getattr(settings, 'FRONTEND_URL', 'Not configured')
        backend_url = getattr(settings, 'BACKEND_URL', 'Not configured')
        
        info.append(f"Frontend URL: {frontend_url}")
        info.append(f"Backend URL: {backend_url}")

        if self.verbose:
            for item in info:
                self.stdout.write(f"  ‚Ä¢ {item}")

        if issues:
            for issue in issues:
                self.stdout.write(self.style.ERROR(f"  ‚ùå {issue}"))
            return {'status': 'failed', 'issues': issues, 'info': info}
        
        return {'status': 'success', 'info': info}

    def check_jwt_keys(self, options):
        """Check JWT RSA key configuration and accessibility"""
        issues = []
        info = []
        
        try:
            # Check algorithm configuration
            algorithm = settings.SIMPLE_JWT.get('ALGORITHM', 'Not set')
            info.append(f"JWT Algorithm: {algorithm}")
            
            if algorithm == 'RS256':
                # Check RSA key files
                try:
                    from core.security_modules.jwt_keys import JWTKeyManager
                    key_manager = JWTKeyManager()
                    
                    info.append(f"Key directory: {key_manager.key_dir}")
                    info.append(f"Private key exists: {key_manager.private_key_file.exists()}")
                    info.append(f"Public key exists: {key_manager.public_key_file.exists()}")
                    
                    if key_manager.keys_exist():
                        # Check file permissions
                        private_perms = oct(os.stat(key_manager.private_key_file).st_mode)[-3:]
                        public_perms = oct(os.stat(key_manager.public_key_file).st_mode)[-3:]
                        
                        info.append(f"Private key permissions: {private_perms}")
                        info.append(f"Public key permissions: {public_perms}")
                        
                        if private_perms != '600':
                            issues.append(f"Private key permissions insecure: {private_perms} (should be 600)")
                            
                            if options.get('fix_permissions'):
                                os.chmod(key_manager.private_key_file, 0o600)
                                self.stdout.write(self.style.SUCCESS("  ‚úÖ Fixed private key permissions"))
                        
                        # Try loading keys
                        try:
                            private_key = key_manager.load_private_key()
                            public_key = key_manager.load_public_key()
                            info.append(f"Private key size: {len(private_key)} bytes")
                            info.append(f"Public key size: {len(public_key)} bytes")
                            info.append("Keys loaded successfully")
                        except Exception as e:
                            issues.append(f"Failed to load keys: {e}")
                    else:
                        issues.append("RSA key files not found")
                        # Try to generate them
                        try:
                            key_manager.ensure_keys_exist()
                            info.append("Generated missing RSA keys")
                        except Exception as e:
                            issues.append(f"Failed to generate keys: {e}")
                            
                except ImportError as e:
                    issues.append(f"Failed to import JWTKeyManager: {e}")
                    
            elif algorithm == 'HS256':
                # Check symmetric key
                signing_key = settings.SIMPLE_JWT.get('SIGNING_KEY')
                if signing_key:
                    info.append(f"Signing key length: {len(signing_key)} chars")
                    info.append("Using symmetric key algorithm (HS256)")
                else:
                    issues.append("No signing key configured for HS256")
            else:
                issues.append(f"Unsupported JWT algorithm: {algorithm}")

        except Exception as e:
            issues.append(f"JWT key check failed: {e}")

        if self.verbose:
            for item in info:
                self.stdout.write(f"  ‚Ä¢ {item}")

        if issues:
            for issue in issues:
                self.stdout.write(self.style.ERROR(f"  ‚ùå {issue}"))
            return {'status': 'failed', 'issues': issues, 'info': info}

        return {'status': 'success', 'info': info}

    def check_algorithm_compatibility(self, options):
        """Check JWT algorithm compatibility and fallback mechanisms"""
        issues = []
        info = []
        
        try:
            # Get configured algorithm
            algorithm = settings.SIMPLE_JWT.get('ALGORITHM', 'Not set')
            info.append(f"Configured algorithm: {algorithm}")
            
            # Check if keys match algorithm
            if algorithm == 'RS256':
                try:
                    signing_key = settings.SIMPLE_JWT.get('SIGNING_KEY')
                    verifying_key = settings.SIMPLE_JWT.get('VERIFYING_KEY')
                    
                    if signing_key and verifying_key:
                        info.append("RSA keys configured for RS256")
                        
                        # Validate key format
                        signing_key_str = signing_key.decode('utf-8') if isinstance(signing_key, bytes) else str(signing_key)
                        verifying_key_str = verifying_key.decode('utf-8') if isinstance(verifying_key, bytes) else str(verifying_key)
                        
                        if 'BEGIN PRIVATE KEY' in signing_key_str or 'BEGIN RSA PRIVATE KEY' in signing_key_str:
                            info.append("Private key format: Valid PEM")
                        else:
                            issues.append("Private key format invalid")
                            
                        if 'BEGIN PUBLIC KEY' in verifying_key_str:
                            info.append("Public key format: Valid PEM")
                        else:
                            issues.append("Public key format invalid")
                    else:
                        issues.append("RSA keys not configured despite RS256 algorithm")
                        
                except Exception as e:
                    issues.append(f"Failed to check RSA keys: {e}")
                    
            elif algorithm == 'HS256':
                signing_key = settings.SIMPLE_JWT.get('SIGNING_KEY')
                if signing_key:
                    info.append("Symmetric key configured for HS256")
                    if len(signing_key) < 32:
                        issues.append("Signing key too short for security")
                else:
                    issues.append("No signing key for HS256 algorithm")
                    
            # Test algorithm compatibility with cryptography library
            try:
                import jwt
                from cryptography.hazmat.primitives import serialization
                
                if algorithm == 'RS256':
                    # Test encoding/decoding with RSA
                    test_payload = {'test': 'payload', 'exp': timezone.now() + timedelta(minutes=1)}
                    signing_key = settings.SIMPLE_JWT.get('SIGNING_KEY')
                    verifying_key = settings.SIMPLE_JWT.get('VERIFYING_KEY')
                    
                    if signing_key and verifying_key:
                        # Test encode
                        token = jwt.encode(test_payload, signing_key, algorithm='RS256')
                        info.append("Token encoding: Success")
                        
                        # Test decode
                        decoded = jwt.decode(token, verifying_key, algorithms=['RS256'])
                        info.append("Token decoding: Success")
                        
                elif algorithm == 'HS256':
                    # Test encoding/decoding with HMAC
                    test_payload = {'test': 'payload', 'exp': timezone.now() + timedelta(minutes=1)}
                    signing_key = settings.SIMPLE_JWT.get('SIGNING_KEY')
                    
                    if signing_key:
                        token = jwt.encode(test_payload, signing_key, algorithm='HS256')
                        decoded = jwt.decode(token, signing_key, algorithms=['HS256'])
                        info.append("HMAC token operations: Success")
                        
            except Exception as e:
                issues.append(f"Algorithm compatibility test failed: {e}")

        except Exception as e:
            issues.append(f"Algorithm compatibility check failed: {e}")

        if self.verbose:
            for item in info:
                self.stdout.write(f"  ‚Ä¢ {item}")

        if issues:
            for issue in issues:
                self.stdout.write(self.style.ERROR(f"  ‚ùå {issue}"))
            return {'status': 'failed', 'issues': issues, 'info': info}

        return {'status': 'success', 'info': info}

    def check_token_operations(self, options):
        """Test JWT token generation and verification"""
        issues = []
        info = []
        
        try:
            # Create a test user or use existing one
            import uuid
            test_email = f'jwt_test_user_{uuid.uuid4().hex[:8]}@example.com'
            test_user, created = User.objects.get_or_create(
                email=test_email,
                defaults={
                    'first_name': 'Test',
                    'last_name': 'User', 
                    'is_active': True,
                    'username': test_email  # Ensure username is unique
                }
            )
            
            if created:
                info.append("Created temporary test user")
            else:
                info.append("Using existing test user")
            
            # Test token generation
            try:
                refresh = RefreshToken.for_user(test_user)
                access = refresh.access_token
                
                info.append(f"Refresh token generated: {len(str(refresh))} chars")
                info.append(f"Access token generated: {len(str(access))} chars")
                
                # Test token validation
                try:
                    # Validate access token
                    from rest_framework_simplejwt.tokens import UntypedToken
                    validated_access = UntypedToken(str(access))
                    info.append("Access token validation: Success")
                    
                    # Validate refresh token
                    validated_refresh = UntypedToken(str(refresh))
                    info.append("Refresh token validation: Success")
                    
                    # Test token refresh
                    new_access = refresh.access_token
                    info.append("Token refresh: Success")
                    
                except (InvalidToken, TokenError) as e:
                    issues.append(f"Token validation failed: {e}")
                    
            except Exception as e:
                issues.append(f"Token generation failed: {e}")
                
            # Test JWT cookie authentication
            try:
                factory = RequestFactory()
                request = factory.get('/api/test/')
                
                # Simulate cookie authentication
                auth = JWTCookieAuthentication()
                
                # Test without cookies (should fallback)
                result = auth.authenticate(request)
                info.append(f"Auth without cookies: {result}")
                
                # Test with cookies
                request.COOKIES[getattr(settings, 'JWT_ACCESS_COOKIE_NAME', 'access_token')] = str(access)
                result = auth.authenticate(request)
                
                if result:
                    user, token = result
                    info.append(f"Cookie authentication success: User {user.email}")
                else:
                    issues.append("Cookie authentication failed")
                    
            except Exception as e:
                issues.append(f"Cookie authentication test failed: {e}")
                
            # Cleanup test user if created
            if created:
                test_user.delete()
                info.append("Cleaned up test user")

        except Exception as e:
            issues.append(f"Token operations test failed: {e}")

        if self.verbose:
            for item in info:
                self.stdout.write(f"  ‚Ä¢ {item}")

        if issues:
            for issue in issues:
                self.stdout.write(self.style.ERROR(f"  ‚ùå {issue}"))
            return {'status': 'failed', 'issues': issues, 'info': info}

        return {'status': 'success', 'info': info}

    def check_cookie_configuration(self, options):
        """Check JWT cookie settings and compatibility"""
        issues = []
        info = []
        
        try:
            # Cookie settings
            cookie_settings = {
                'JWT_COOKIE_SAMESITE': getattr(settings, 'JWT_COOKIE_SAMESITE', 'Lax'),
                'JWT_COOKIE_SECURE': getattr(settings, 'JWT_COOKIE_SECURE', True),
                'JWT_COOKIE_DOMAIN': getattr(settings, 'JWT_COOKIE_DOMAIN', None),
                'JWT_ACCESS_COOKIE_NAME': getattr(settings, 'JWT_ACCESS_COOKIE_NAME', 'access_token'),
                'JWT_REFRESH_COOKIE_NAME': getattr(settings, 'JWT_REFRESH_COOKIE_NAME', 'refresh_token'),
            }
            
            for key, value in cookie_settings.items():
                info.append(f"{key}: {value}")
            
            # Check for mobile Safari compatibility
            samesite = cookie_settings['JWT_COOKIE_SAMESITE']
            secure = cookie_settings['JWT_COOKIE_SECURE']
            
            if samesite == 'None' and not secure:
                issues.append("SameSite=None requires Secure=True for mobile Safari compatibility")
            elif samesite == 'None' and secure:
                info.append("Mobile Safari compatible: SameSite=None with Secure=True")
            
            # Check cross-origin configuration
            frontend_url = getattr(settings, 'FRONTEND_URL', '')
            backend_url = getattr(settings, 'BACKEND_URL', '')
            
            if frontend_url and backend_url:
                from urllib.parse import urlparse
                frontend_domain = urlparse(frontend_url).netloc
                backend_domain = urlparse(backend_url).netloc
                
                is_cross_origin = frontend_domain != backend_domain
                info.append(f"Cross-origin setup: {is_cross_origin}")
                info.append(f"Frontend domain: {frontend_domain}")
                info.append(f"Backend domain: {backend_domain}")
                
                if is_cross_origin and samesite != 'None':
                    issues.append(f"Cross-origin setup but SameSite={samesite} (should be None)")
                elif not is_cross_origin and samesite == 'None':
                    info.append("Same-origin setup with SameSite=None (may not be necessary)")
            
            # Test cookie middleware
            try:
                from django.http import HttpResponse
                from apps.authentication.cookie_middleware import set_jwt_cookies, clear_jwt_cookies
                
                response = HttpResponse()
                test_tokens = {
                    'access': 'test_access_token',
                    'refresh': 'test_refresh_token'
                }
                
                # Test setting cookies
                set_jwt_cookies(response, test_tokens)
                info.append("Cookie middleware set_jwt_cookies: Success")
                
                # Test clearing cookies
                clear_jwt_cookies(response)
                info.append("Cookie middleware clear_jwt_cookies: Success")
                
            except Exception as e:
                issues.append(f"Cookie middleware test failed: {e}")

        except Exception as e:
            issues.append(f"Cookie configuration check failed: {e}")

        if self.verbose:
            for item in info:
                self.stdout.write(f"  ‚Ä¢ {item}")

        if issues:
            for issue in issues:
                self.stdout.write(self.style.ERROR(f"  ‚ùå {issue}"))
            return {'status': 'failed', 'issues': issues, 'info': info}

        return {'status': 'success', 'info': info}

    def check_cors_security(self, options):
        """Check CORS and security configuration"""
        issues = []
        info = []
        
        try:
            # CORS settings
            cors_settings = {
                'CORS_ALLOW_CREDENTIALS': getattr(settings, 'CORS_ALLOW_CREDENTIALS', False),
                'CORS_ALLOW_ALL_ORIGINS': getattr(settings, 'CORS_ALLOW_ALL_ORIGINS', False),
                'CORS_ALLOWED_ORIGINS': getattr(settings, 'CORS_ALLOWED_ORIGINS', []),
                'CSRF_TRUSTED_ORIGINS': getattr(settings, 'CSRF_TRUSTED_ORIGINS', []),
            }
            
            info.append(f"CORS allow credentials: {cors_settings['CORS_ALLOW_CREDENTIALS']}")
            info.append(f"CORS allow all origins: {cors_settings['CORS_ALLOW_ALL_ORIGINS']}")
            info.append(f"CORS allowed origins: {len(cors_settings['CORS_ALLOWED_ORIGINS'])} configured")
            info.append(f"CSRF trusted origins: {len(cors_settings['CSRF_TRUSTED_ORIGINS'])} configured")
            
            # Security warnings
            if cors_settings['CORS_ALLOW_ALL_ORIGINS']:
                issues.append("CORS_ALLOW_ALL_ORIGINS=True is insecure in production")
            
            if not cors_settings['CORS_ALLOW_CREDENTIALS']:
                issues.append("CORS_ALLOW_CREDENTIALS=False prevents cookie authentication")
            
            if not cors_settings['CORS_ALLOWED_ORIGINS']:
                issues.append("No CORS allowed origins configured")
            
            # SSL/HTTPS settings
            ssl_settings = {
                'SECURE_SSL_REDIRECT': getattr(settings, 'SECURE_SSL_REDIRECT', False),
                'SESSION_COOKIE_SECURE': getattr(settings, 'SESSION_COOKIE_SECURE', False),
                'CSRF_COOKIE_SECURE': getattr(settings, 'CSRF_COOKIE_SECURE', False),
                'SECURE_PROXY_SSL_HEADER': getattr(settings, 'SECURE_PROXY_SSL_HEADER', None),
            }
            
            for key, value in ssl_settings.items():
                info.append(f"{key}: {value}")
            
            # Check for production security
            if not settings.DEBUG:
                if not ssl_settings['SESSION_COOKIE_SECURE']:
                    issues.append("SESSION_COOKIE_SECURE should be True in production")
                if not ssl_settings['CSRF_COOKIE_SECURE']:
                    issues.append("CSRF_COOKIE_SECURE should be True in production")

        except Exception as e:
            issues.append(f"CORS/Security check failed: {e}")

        if self.verbose:
            for item in info:
                self.stdout.write(f"  ‚Ä¢ {item}")

        if issues:
            for issue in issues:
                self.stdout.write(self.style.WARNING(f"  ‚ö†Ô∏è  {issue}"))
            return {'status': 'warning', 'issues': issues, 'info': info}

        return {'status': 'success', 'info': info}

    def check_authentication_classes(self, options):
        """Check DRF authentication class configuration"""
        issues = []
        info = []
        
        try:
            auth_classes = getattr(settings, 'REST_FRAMEWORK', {}).get('DEFAULT_AUTHENTICATION_CLASSES', [])
            
            info.append(f"Authentication classes: {len(auth_classes)} configured")
            
            for i, auth_class in enumerate(auth_classes):
                info.append(f"  {i+1}. {auth_class}")
                
                # Check if class can be imported
                try:
                    from django.utils.module_loading import import_string
                    import_string(auth_class)
                    info.append(f"     ‚úÖ Import successful")
                except ImportError as e:
                    issues.append(f"Cannot import {auth_class}: {e}")
            
            # Check for JWT cookie authentication
            jwt_cookie_auth = 'apps.authentication.jwt_cookie_authentication.JWTCookieAuthentication'
            if jwt_cookie_auth not in auth_classes:
                issues.append(f"JWTCookieAuthentication not in auth classes")
            else:
                info.append("JWTCookieAuthentication configured")

        except Exception as e:
            issues.append(f"Authentication classes check failed: {e}")

        if self.verbose:
            for item in info:
                self.stdout.write(f"  ‚Ä¢ {item}")

        if issues:
            for issue in issues:
                self.stdout.write(self.style.ERROR(f"  ‚ùå {issue}"))
            return {'status': 'failed', 'issues': issues, 'info': info}

        return {'status': 'success', 'info': info}

    def check_production_environment(self, options):
        """Check production-specific configuration"""
        issues = []
        info = []
        
        try:
            is_production = not settings.DEBUG
            info.append(f"Production mode: {is_production}")
            
            if is_production:
                # Production-specific checks
                
                # Check if running on Railway
                railway_env = os.environ.get('RAILWAY_ENVIRONMENT')
                if railway_env:
                    info.append(f"Railway environment: {railway_env}")
                    
                    # Check Railway-specific headers
                    proxy_header = getattr(settings, 'SECURE_PROXY_SSL_HEADER', None)
                    if proxy_header and proxy_header[0] == 'HTTP_X_FORWARDED_PROTO':
                        info.append("Railway proxy headers configured correctly")
                    else:
                        issues.append("Railway proxy headers may not be configured correctly")
                
                # Check SSL redirect
                ssl_redirect = getattr(settings, 'SECURE_SSL_REDIRECT', False)
                info.append(f"SSL redirect: {ssl_redirect}")
                
                # Check allowed hosts
                allowed_hosts = getattr(settings, 'ALLOWED_HOSTS', [])
                info.append(f"Allowed hosts: {len(allowed_hosts)} configured")
                
                if '*' in allowed_hosts:
                    issues.append("Wildcard in ALLOWED_HOSTS is insecure in production")
                
                # Check database connection
                try:
                    from django.db import connection
                    with connection.cursor() as cursor:
                        cursor.execute("SELECT 1")
                    info.append("Database connection: Success")
                except Exception as e:
                    issues.append(f"Database connection failed: {e}")
                
                # Check Redis/Cache connection
                try:
                    cache.set('diagnostic_test', 'test_value', 30)
                    cached_value = cache.get('diagnostic_test')
                    if cached_value == 'test_value':
                        info.append("Cache connection: Success")
                    else:
                        issues.append("Cache connection failed")
                except Exception as e:
                    issues.append(f"Cache connection failed: {e}")
            
            else:
                info.append("Running in development mode")

        except Exception as e:
            issues.append(f"Production environment check failed: {e}")

        if self.verbose:
            for item in info:
                self.stdout.write(f"  ‚Ä¢ {item}")

        if issues:
            for issue in issues:
                self.stdout.write(self.style.ERROR(f"  ‚ùå {issue}"))
            return {'status': 'failed', 'issues': issues, 'info': info}

        return {'status': 'success', 'info': info}

    def check_database_connectivity(self, options):
        """Check database connectivity and JWT-related tables"""
        issues = []
        info = []
        
        try:
            from django.db import connection
            
            # Test basic connection
            with connection.cursor() as cursor:
                cursor.execute("SELECT version()")
                db_version = cursor.fetchone()[0]
                info.append(f"Database version: {db_version}")
            
            # Check for JWT blacklist tables (if using)
            try:
                from rest_framework_simplejwt.token_blacklist.models import BlacklistedToken
                blacklisted_count = BlacklistedToken.objects.count()
                info.append(f"Blacklisted tokens: {blacklisted_count}")
            except:
                info.append("Token blacklist not available")
            
            # Check user table
            user_count = User.objects.count()
            info.append(f"Total users: {user_count}")
            
            # Check for authentication-related issues
            inactive_users = User.objects.filter(is_active=False).count()
            info.append(f"Inactive users: {inactive_users}")

        except Exception as e:
            issues.append(f"Database connectivity check failed: {e}")

        if self.verbose:
            for item in info:
                self.stdout.write(f"  ‚Ä¢ {item}")

        if issues:
            for issue in issues:
                self.stdout.write(self.style.ERROR(f"  ‚ùå {issue}"))
            return {'status': 'failed', 'issues': issues, 'info': info}

        return {'status': 'success', 'info': info}

    def test_user_authentication(self, user_email):
        """Test authentication flow with a specific user"""
        issues = []
        info = []
        
        try:
            # Get or create user
            try:
                user = User.objects.get(email=user_email)
                info.append(f"Found user: {user.email}")
            except User.DoesNotExist:
                user = User.objects.create_user(
                    username=user_email,
                    email=user_email,
                    first_name='Test',
                    last_name='User',
                    password='testpassword123'
                )
                info.append(f"Created test user: {user.email}")
            
            if not user.is_active:
                issues.append("User is inactive")
                return {'status': 'failed', 'issues': issues, 'info': info}
            
            # Test token generation
            refresh = RefreshToken.for_user(user)
            access = refresh.access_token
            
            info.append("Tokens generated successfully")
            
            # Test authentication
            factory = APIRequestFactory()
            request = factory.get('/api/test/')
            
            # Add required attributes for authentication
            from django.contrib.sessions.backends.db import SessionStore
            request.session = SessionStore()
            
            # Test cookie authentication
            request.COOKIES[getattr(settings, 'JWT_ACCESS_COOKIE_NAME', 'access_token')] = str(access)
            
            auth = JWTCookieAuthentication()
            result = auth.authenticate(request)
            
            if result:
                authenticated_user, token = result
                if authenticated_user.id == user.id:
                    info.append("User authentication successful")
                    
                    # Log successful test
                    log_security_event(
                        SecurityEvent.LOGIN_SUCCESS,
                        user=user,
                        request=request,
                        extra_data={'test': True, 'diagnostic_tool': True}
                    )
                else:
                    issues.append("Authentication returned wrong user")
            else:
                issues.append("User authentication failed")

        except Exception as e:
            issues.append(f"User authentication test failed: {e}")

        if issues:
            return {'status': 'failed', 'issues': issues, 'info': info}

        return {'status': 'success', 'info': info}

    def analyze_auth_logs(self):
        """Analyze recent authentication failures"""
        issues = []
        info = []
        
        try:
            # This would analyze logs if we had a log aggregation system
            # For now, provide basic guidance
            info.append("Log analysis not implemented in this version")
            info.append("To analyze authentication failures:")
            info.append("1. Check Django logs for authentication errors")
            info.append("2. Look for JWT token validation failures")
            info.append("3. Monitor CORS errors in browser console")
            info.append("4. Check for cookie-related errors")
            
        except Exception as e:
            issues.append(f"Log analysis failed: {e}")

        return {'status': 'success', 'info': info, 'issues': issues}

    def provide_summary_and_recommendations(self, results):
        """Provide summary and actionable recommendations"""
        self.stdout.write(f'\nüéØ DIAGNOSTIC SUMMARY')
        self.stdout.write('=' * 60)
        
        passed = sum(1 for r in results.values() if r.get('status') == 'success')
        failed = sum(1 for r in results.values() if r.get('status') == 'failed')
        warnings = sum(1 for r in results.values() if r.get('status') == 'warning')
        errors = sum(1 for r in results.values() if r.get('status') == 'error')
        
        self.stdout.write(f"‚úÖ Passed: {passed}")
        self.stdout.write(f"‚ùå Failed: {failed}")
        self.stdout.write(f"‚ö†Ô∏è  Warnings: {warnings}")
        self.stdout.write(f"üö® Errors: {errors}")
        
        # Collect all issues
        all_issues = []
        for name, result in results.items():
            if result.get('issues'):
                all_issues.extend([(name, issue) for issue in result['issues']])
        
        if all_issues:
            self.stdout.write(f'\nüîß ACTIONABLE RECOMMENDATIONS')
            self.stdout.write('=' * 60)
            
            priority_issues = []
            other_issues = []
            
            for source, issue in all_issues:
                if any(keyword in issue.lower() for keyword in 
                      ['failed', 'not found', 'missing', 'invalid', 'connection']):
                    priority_issues.append((source, issue))
                else:
                    other_issues.append((source, issue))
            
            if priority_issues:
                self.stdout.write(self.style.ERROR('\nüö® HIGH PRIORITY ISSUES:'))
                for i, (source, issue) in enumerate(priority_issues, 1):
                    self.stdout.write(f"{i}. [{source}] {issue}")
            
            if other_issues:
                self.stdout.write(self.style.WARNING('\n‚ö†Ô∏è  OTHER ISSUES:'))
                for i, (source, issue) in enumerate(other_issues, 1):
                    self.stdout.write(f"{i}. [{source}] {issue}")
            
            # Common solutions
            self.stdout.write(f'\nüí° COMMON SOLUTIONS')
            self.stdout.write('=' * 60)
            
            solutions = [
                "1. Ensure RSA keys exist: python manage.py rotate_jwt_keys",
                "2. Check environment variables: DJANGO_SECRET_KEY, FRONTEND_URL, BACKEND_URL",
                "3. Verify CORS settings: CORS_ALLOWED_ORIGINS should include frontend URL",
                "4. For mobile Safari: Use SameSite=None and Secure=True for cross-origin",
                "5. Check database connectivity and migrations",
                "6. Verify SSL/HTTPS configuration in production",
                "7. Monitor browser console for cookie/CORS errors",
                "8. Test with: python manage.py diagnose_jwt_auth --test-user test@example.com"
            ]
            
            for solution in solutions:
                self.stdout.write(f"  {solution}")
        
        else:
            self.stdout.write(self.style.SUCCESS('\n‚úÖ All checks passed! JWT authentication should be working correctly.'))
        
        self.stdout.write(f'\nüìä Diagnostic completed at {datetime.now()}')